"""sync ORM AnalyticsSnapshot indexes (SQLite-safe)

Revision ID: 81d258beb4fc
Revises: ce01e106f155
Create Date: 2025-08-27 12:46:08.095297

This migration was auto-generated to sync ORM indexes. On SQLite, we cannot ALTER constraints and re-running migrations may attempt to recreate indexes. To keep local dev (SQLite) green and idempotent, we guard those operations and use raw `CREATE INDEX IF NOT EXISTS` statements instead of Alembic's `create_index` helper.
"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision: str = '81d258beb4fc'
down_revision: Union[str, Sequence[str], None] = 'ce01e106f155'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def _is_sqlite() -> bool:
    bind = op.get_bind()
    return bind.dialect.name == 'sqlite'


def upgrade() -> None:
    """Upgrade schema (dialect-aware)."""
    if _is_sqlite():
        # SQLite: create missing indexes only; skip constraint churn.
        # Use raw SQL with IF NOT EXISTS to make re-runs idempotent.
        op.execute('CREATE INDEX IF NOT EXISTS ix_analytics_snapshots_id ON analytics_snapshots (id)')
        op.execute('CREATE INDEX IF NOT EXISTS ix_content_items_id ON content_items (id)')
        op.execute('CREATE INDEX IF NOT EXISTS ix_sites_id ON sites (id)')
        # Ensure unique index on sites.domain (approximate of UNIQUE constraint)
        op.execute('CREATE UNIQUE INDEX IF NOT EXISTS ix_sites_domain ON sites (domain)')
        return

    # Non-SQLite (e.g., Postgres): keep the autogenerated intent
    op.create_index(op.f('ix_analytics_snapshots_id'), 'analytics_snapshots', ['id'], unique=False)
    op.create_index(op.f('ix_content_items_id'), 'content_items', ['id'], unique=False)
    op.drop_constraint(op.f('content_items_site_id_fkey'), 'content_items', type_='foreignkey')
    op.create_foreign_key(None, 'content_items', 'sites', ['site_id'], ['id'])
    op.drop_constraint(op.f('uq_sites_domain'), 'sites', type_='unique')
    op.create_index(op.f('ix_sites_domain'), 'sites', ['domain'], unique=True)
    op.create_index(op.f('ix_sites_id'), 'sites', ['id'], unique=False)


def downgrade() -> None:
    """Downgrade schema (dialect-aware)."""
    if _is_sqlite():
        # Drop the indexes we created, if present; ignore constraints
        op.execute('DROP INDEX IF EXISTS ix_analytics_snapshots_id')
        op.execute('DROP INDEX IF EXISTS ix_content_items_id')
        op.execute('DROP INDEX IF EXISTS ix_sites_id')
        op.execute('DROP INDEX IF EXISTS ix_sites_domain')
        return

    # Non-SQLite: reverse autogenerated intent
    op.drop_index(op.f('ix_sites_id'), table_name='sites')
    op.drop_index(op.f('ix_sites_domain'), table_name='sites')
    op.create_unique_constraint(op.f('uq_sites_domain'), 'sites', ['domain'], postgresql_nulls_not_distinct=False)
    op.drop_constraint(None, 'content_items', type_='foreignkey')
    op.create_foreign_key(op.f('content_items_site_id_fkey'), 'content_items', 'sites', ['site_id'], ['id'], ondelete='CASCADE')
    op.drop_index(op.f('ix_content_items_id'), table_name='content_items')
    op.drop_index(op.f('ix_analytics_snapshots_id'), table_name='analytics_snapshots')
